<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/22/hello-world/"/>
      <url>/2018/08/22/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>cocoapods 资源管理</title>
      <link href="/2017/06/15/cocoapods/"/>
      <url>/2017/06/15/cocoapods/</url>
      <content type="html"><![CDATA[<h1 id="cocoapods"><a href="#cocoapods" class="headerlink" title="cocoapods"></a>cocoapods</h1><p>##resource_bundles</p><figure class="highlight podspec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spec.resource_bundles = &#123;</span><br><span class="line">  <span class="string">'MyLibrary'</span> =&gt; [<span class="string">'Resources/*.png'</span>],</span><br><span class="line">  <span class="string">'OtherResources'</span> =&gt; [<span class="string">'OtherResources/*.png'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resource_bundles</code>显式地做了 bundle 层面的分组<br>上面的写法意思是在你的framework下生成<code>MyLibrary.bundle</code>和<code>OtherResources.bundle</code></p><p>###坑</p><ol><li>使用了Resources/**/*的写法 导致Resources下的目录和文件 递归的被copy到Resources目录下 造成资源的重复</li></ol><p>以下是常用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spec.resource_bundles = &#123;</span><br><span class="line">  &apos;MyLibrary&apos; =&gt; [&apos;Resources/source&apos;], // Resources/source文件夹下的所有内容包括子文件夹</span><br><span class="line">  &apos;MyLibrary1&apos; =&gt; [&apos;Resources/&#123;source,source2&#125;&apos;], // Resources/source和Resources/source1文件夹下的所有内容包括子文件夹</span><br><span class="line">  &apos;MyLibrary2&apos; =&gt; [&apos;Resources/**/*.&#123;png,xib&#125;&apos;], // Resources/source文件夹下的所有.png结尾的图片和xib文件</span><br><span class="line">  </span><br><span class="line">  &apos;OtherResources&apos; =&gt; [&apos;OtherResources/**/*.png&apos;] // 递归OtherResources文件夹下的所有以.png结尾的图片</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方式会生成多个.bundle文件 当然也可以一个.bundle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spec.resource_bundles = &#123;</span><br><span class="line">  &apos;MyLibrary&apos; =&gt; [&apos;&apos;Resources/*.&#123;png,xib&#125;&apos;, &apos;Resources/source&apos;], // Resources/source文件夹下的所有内容包括子文件夹 和 Resources文件夹下的所有以.png结尾的图片</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##访问bundle</p><p>由于 iOS 8 Dynamic Frameworks 特性的引入，CocoaPods 能帮你打包 framework 了<br>0.36 版的 release note很详细地说明了加入 framework 特性所带来的变化。一个显著区别就是当你的 pod 库以 framework 形式被使用时，你的资源不是被拷贝到 mainBundle 下，而是被放到 pod 的最终产物—— framework 里。此时，你必须保证自己在访问这个 framework 的 bundle，而不是 client target 的。</p><p>上面这段代码可以返回某个 class 对应的 bundle 对象。具体的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSBundle bundleForClass:&lt;#ClassFromPodspec#&gt;]</span><br></pre></td></tr></table></figure><ul><li>如果你的 pod 以 framework 形式被链接，那么返回这个 framework 的 bundle 即 framework 的 bundle 根目录。</li><li>如果以静态库（.a）的形式被链接，那么返回 client target 的 bundle，即 mainBundle。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSBundle *bundle = [NSBundle bundleForClass:[self class]];</span><br><span class="line">    return [bundle URLForResource:@&quot;MyLibrary&quot; withExtension:@&quot;bundle&quot;];</span><br></pre></td></tr></table></figure><p>先拿到最外面的 bundle。 对 framework 链接方式来说就是 framework 的 bundle 根目录，对静态库链接方式来说就是 target client 的 main bundle，然后再去找下面名为 MyLibrary 的 bundle 对象。<br>如果想拿到xxx.bundle里的对象 比如 xxx.bundle/source/main.jsbundle<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSBundle bundleForClass:[self class]] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot; subdirectory:@&quot;xxx.bundle/source&quot;];</span><br></pre></td></tr></table></figure></p><h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><ol><li>访问主工程里的图片 如下方式即可 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIImage imageNamed:name]</span><br></pre></td></tr></table></figure></li></ol><p>这种方式 是否可访问main.bundle里文件夹下的图片 ?</p><ol start="2"><li>访问framework里bundle或某个bundle的图片资源 如下方式即可 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIImage imageNamed:name inBundle:bundle compatibleWithTraitCollection:nil]</span><br></pre></td></tr></table></figure></li></ol><p>注意:<code>+ imageNamed:inBundle:compatibleWithTraitCollection:</code> 这个方法 iOS 8 才加入的,之前可以如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIImage imageWithContentsOfFile:[bundle pathForResource:name ofType:@&quot;png&quot;]];</span><br></pre></td></tr></table></figure></p><p>#引用<br><a href="http://blog.xianqu.org/2015/08/pod-resources/" target="_blank" rel="noopener">给 Pod 添加资源文件</a></p>]]></content>
      
      <categories>
          
          <category> Cocopods </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>async 小计</title>
      <link href="/2017/06/15/async/"/>
      <url>/2017/06/15/async/</url>
      <content type="html"><![CDATA[<p>#语法</p><hr><ol><li><code>async</code>函数返回一个Promise对象。</li></ol><p><code>async</code>函数内部<code>return</code>语句返回的值，会成为`then方法回调函数的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。</p><p>async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">  v =&gt; <span class="built_in">console</span>.log(v),</span><br><span class="line">  e =&gt; <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure><ol start="2"><li>async函数返回的Promise对象，必须等到内部所有await命令的Promise对象执行完，才会发生状态改变。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">  <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>正常情况下，await命令后面是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>await命令后面的Promise对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。</p><p>只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。</p><p>为了避免这个问题，可以将第一个await放在try…catch结构里面，这样第二个await就会执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>另一种方法是await后面的Promise对象再跟一个catch方面，处理前面可能出现的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>如果有多个await命令，可以统一放在try…catch结构中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> val1 = <span class="keyword">await</span> firstStep();</span><br><span class="line">    <span class="keyword">var</span> val2 = <span class="keyword">await</span> secondStep(val1);</span><br><span class="line">    <span class="keyword">var</span> val3 = <span class="keyword">await</span> thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Final: '</span>, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure><p>上面代码中，async函数f执行后，await后面的Promise对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async函数的实现”。</p><p>防止出错的方法，也是将其放在try…catch代码块之中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span>(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Promise 小计</title>
      <link href="/2017/06/15/Promise/"/>
      <url>/2017/06/15/Promise/</url>
      <content type="html"><![CDATA[<p>#Promise</p><p>##Promise.prototype.catch()</p><p>如果Promise状态已经变成Resolved，再抛出错误是无效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。</p><p>Promise对象的错误具有<strong>冒泡</strong>性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p><p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，someAsyncThing函数产生的Promise对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。注意，Chrome浏览器不遵守这条规定，它会抛出错误“ReferenceError: x is not defined”。</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Crash Log 分析</title>
      <link href="/2016/04/06/crash_log/"/>
      <url>/2016/04/06/crash_log/</url>
      <content type="html"><![CDATA[<h1 id="crash-log-符号化"><a href="#crash-log-符号化" class="headerlink" title="crash log 符号化"></a>crash log 符号化</h1><ol><li>导出crash log</li></ol><p>通过Xcode的Organizer查看某台iphone设备的DeviceLog，选择需要的crash log，导出XXX.crash文件。</p><ol start="2"><li>找到对应的app文件</li></ol><p>找到当前iphone设备上安装的ipa文件，更改文件后缀名为zip，解压后得到Payload文件夹，你需要的app文件就在其中了。</p><ol start="3"><li>找到对应build版本的dSYM文件</li></ol><p>dSYM文件是iOS编译后保存16进制函数地址映射信息的文件，每次应用程序build后，都会生成对应的xxx.app, xxx.app.dSYM文件。</p><ol start="4"><li>确定dSYM、app以及crash文件的关系</li></ol><p>每一个xx.app, xxx.app.dSYM文件都拥有相应的uuid，crash文件也有uuid,只有三者uuid一至才表明之三者可以解析出正确的日志文件。<br>查看xx.app文件的uuid的方法，在terminal中输入命令：</p><p>dwarfdump –uuid xxx.app/xxx (xxx工程名)</p><p>查看xx.app.dSYM文件的uuid的方法，在terminal中输入命令：</p><p>dwarfdump –uuid xxx.app.dSYM (xxx工程名)</p><p>而.crash的uuid位于，crash日志中的Binary Images:中的第一行。如：</p><p>armv7 <8bdeaf1a0b233ac199728c2a0ebb4165></8bdeaf1a0b233ac199728c2a0ebb4165></p><figure class="highlight plain"><figcaption><span>log</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">### 1.进程信息 ###</span><br><span class="line">Incident Identifier: E4201F10-6F5F-40F9-B938-BB3DA8ED7D50</span><br><span class="line">CrashReporter Key:   TODO</span><br><span class="line">Hardware Model:      iPhone4,1</span><br><span class="line">Process:         Taobao4iPhone [3538]</span><br><span class="line">Path:            /var/mobile/Applications/E3B51E77-D44D-4B3E-8767-B7DC2008D138/Taobao4iPhone.app/Taobao4iPhone</span><br><span class="line">Identifier:      com.taobao.taobao4iphone</span><br><span class="line">Version:         4.8.1</span><br><span class="line">Code Type:       ARM</span><br><span class="line">Parent Process:  launchd [1]</span><br><span class="line"></span><br><span class="line">### 2.基本信息 ###</span><br><span class="line">Date/Time:       2014-09-16 21:39:30 +0000</span><br><span class="line">OS Version:      iPhone OS 7.1.2 (11D257)</span><br><span class="line">Report Version:  104</span><br><span class="line"></span><br><span class="line">### 3.异常信息 ###</span><br><span class="line">Exception Type:  SIGSEGV</span><br><span class="line">Exception Codes: SEGV_ACCERR at 0xa2400db3</span><br><span class="line">Crashed Thread:  0</span><br><span class="line"></span><br><span class="line">### 4.线程回溯 ###</span><br><span class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</span><br><span class="line"></span><br><span class="line">### 5.Crash调用堆栈 ###</span><br><span class="line">Thread 0 Crashed:</span><br><span class="line">0   libobjc.A.dylib                     0x3838760c 0x38375000 + 75276</span><br><span class="line">1   Taobao4iPhone                       0x012c03e1 0x66000 + 19244001</span><br><span class="line">2   Taobao4iPhone                       0x012c054f 0x66000 + 19244367</span><br><span class="line">3   Foundation                          0x2e4de163 0x2e419000 + 807267</span><br><span class="line">4   CoreFoundation                      0x2dac9167 0x2da2a000 + 651623</span><br><span class="line">5   CoreFoundation                      0x2dac8d7f 0x2da2a000 + 650623</span><br><span class="line">6   CoreFoundation                      0x2dac711b 0x2da2a000 + 643355</span><br><span class="line">7   CoreFoundation                      0x2da31ebf 0x2da2a000 + 32447</span><br><span class="line">8   CoreFoundation                      0x2da31ca3 0x2da2a000 + 31907</span><br><span class="line">9   GraphicsServices                    0x3298b663 0x32982000 + 38499</span><br><span class="line">10  UIKit                               0x3037e14d 0x30310000 + 450893</span><br><span class="line">11  Taobao4iPhone                       0x0006b349 0x66000 + 21321</span><br><span class="line">12  Taobao4iPhone                       0x0006a5e8 0x66000 + 17896</span><br><span class="line"></span><br><span class="line">Thread 1:</span><br><span class="line">0   libsystem_kernel.dylib              0x38928808 0x38928000 + 2056</span><br><span class="line">1   libdispatch.dylib                   0x38869e03 0x3885f000 + 44547</span><br><span class="line"></span><br><span class="line">### 5.动态库信息 ###</span><br><span class="line">Binary Images:</span><br><span class="line">   0x66000 -  0x19cdfff +Taobao4iPhone armv7  &lt;43ebe409980f31fd9be165a64b002af5&gt; /var/mobile/Applications/E3B51E77-D44D-4B3E-8767-B7DC2008D138/Taobao4iPhone.app/Taobao4iPhone</span><br><span class="line"> 0x9fa9000 -  0x9fb4fff  QuickSpeak armv7  &lt;eda7aee380373fad88f17971512f2777&gt; /System/Library/AccessibilityBundles/QuickSpeak.bundle/QuickSpeak</span><br><span class="line">0x2c667000 - 0x2c669fff  AXSpeechImplementation armv7  &lt;fceb6d31f58d3c41afa9ace822d266a7&gt; /System/Library/AccessibilityBundles/AXSpeechImplementation.bundle/AXSpeechImplementation</span><br></pre></td></tr></table></figure><p>我从中选出一条调用进行符号化：</p><p>1   Taobao4iPhone                       0x012c03e1 0x66000 + 19244001<br>使用下面的命令符号化：</p><p>atos -arch armv7 -o “Taobao4iPhone.app.dSYM” -l 0x66000 0x012c03e1<br>结果：</p><p>1   Taobao4iPhone   0x012c03e1 -[TBSNSPagesContainerView subviewLayoutPage:] (in Taobao4iPhone) (TBSNSPagesContainer.m:227)<br>可以看到崩溃的类为TBSNSPagesContainerView，函数为subviewLayoutPage，文件名是TBSNSPagesContainer.m，行数是227行。</p><p>我们返回来看一下atos用法： </p><p><code>atos -o dysm文件路径 -l  模块load地址 -arch cpu指令集种类 调用方法的地址</code><br>dysm文件路径：可以在Xcode Organizer的Archives标签栏下找到所有已归档的应用文件。它保存了编译过程的详细信息，其中包括符号信息。<br>模块load地址：模块加载的基地址，可以在日志的<em>动态库信息</em>中找到对应模块的基地址。这里为0x66000<br>cpu指令集种类：可以为armv6 armv7 armv7s arm64。具体用哪个，可以参考对应模块的<em>动态库信息</em>中确定。如</p><p>0x66000 -  0x19cdfff +Taobao4iPhone armv7  <43ebe409980f31fd9be165a64b002af5> /var/mobile/Applications/E3B51E77-D44D-4B3E-8767-B7DC2008D138/Taobao4iPhone.app/Taobao4iPhone<br>那么Taobao4iPhone模块的cpu指令集为armv7<br>调用方法的地址:这里是0x012c03e1</43ebe409980f31fd9be165a64b002af5></p><p>#问题</p><ol><li>Error: “DEVELOPER_DIR” is not defined at /usr/local/bin/symbolicatecrash line 53.<ul><li>DEVELOPER_DIR 未设置</li><li>export DEVELOPER_DIR=”/Applications/Xcode.app/Contents/Developer”</li></ul></li><li>No crash report version in hot.crash at ./symbolicatecrash line 1013.<ul><li>缺少 report version</li></ul></li><li>Error: Can’t find “Binary Images” section in log file at ./symbolicatecrash line 469.<ul><li>缺少 Binary Images</li></ul></li><li>Use of uninitialized value $hwModel in concatenation (.) or string at ./symbolicatecrash line 138.<ul><li>缺少 hardwareModel </li></ul></li></ol><p>#引用</p><p><a href="http://blog.csdn.net/diyagoanyhacker/article/details/41247411" target="_blank" rel="noopener">iOS Crash 分析（文三）- 符号化崩溃日志</a></p><p><a href="http://wiki.sankuai.com/pages/viewpage.action?pageId=411575079" target="_blank" rel="noopener">iOS crash 日志分析</a></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
